"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// index.ts
var index_exports = {};
__export(index_exports, {
  ogr2ogr: () => ogr2ogr
});
module.exports = __toCommonJS(index_exports);
var import_node_child_process = require("child_process");
var import_node_fs = require("fs");
var import_node_os = require("os");
var import_node_path = require("path");
var import_node_stream = require("stream");
var import_archiver = __toESM(require("archiver"), 1);
var stdoutRe = /csv|geojson|georss|gml|gmt|gpx|jml|kml|mapml|pdf|vdv/i;
var vsiStdIn = "/vsistdin/";
var vsiStdOut = "/vsistdout/";
var uniq = Date.now();
var Ogr2ogr = class {
  inputStream;
  inputPath;
  outputPath;
  outputFormat;
  outputExt;
  customCommand;
  customOptions;
  customDestination;
  customEnv;
  timeout;
  maxBuffer;
  skipFailures;
  constructor(input, opts = {}) {
    this.inputPath = opts.inputFormat ? opts.inputFormat + ":" + vsiStdIn : vsiStdIn;
    this.outputFormat = opts.format ?? "GeoJSON";
    this.customCommand = opts.command;
    this.customOptions = opts.options;
    this.customDestination = opts.destination;
    this.customEnv = opts.env;
    this.timeout = opts.timeout ?? 0;
    this.maxBuffer = opts.maxBuffer ?? 1024 * 1024 * 50;
    this.skipFailures = opts.skipFailures ?? true;
    let { path, ext } = this.newOutputPath(this.outputFormat);
    this.outputPath = path;
    this.outputExt = ext;
    if (input instanceof import_node_stream.Readable) {
      this.inputStream = input;
    } else if (typeof input === "string") {
      this.inputPath = this.newInputPath(input);
    } else {
      this.inputStream = import_node_stream.Readable.from([JSON.stringify(input)]);
    }
  }
  exec(cb) {
    this.run().then((res) => cb(null, res)).catch((err) => cb(err));
  }
  then(onfulfilled, onrejected) {
    return this.run().then(onfulfilled, onrejected);
  }
  newInputPath(p) {
    let path = "";
    let ext = (0, import_node_path.extname)(p);
    switch (ext) {
      case ".zip":
        path = "/vsizip/";
        break;
      case ".gz":
        path = "/vsigzip/";
        break;
      case ".tar":
        path = "/vsitar/";
        break;
    }
    if (/^(http|ftp)/.test(p)) {
      path += "/vsicurl/" + p;
      return path;
    }
    path += p;
    return path;
  }
  newOutputPath(f) {
    let ext = "." + f.toLowerCase();
    if (stdoutRe.test(this.outputFormat)) {
      return { path: vsiStdOut, ext };
    }
    let path = (0, import_node_path.join)((0, import_node_os.tmpdir)(), "/ogr_" + uniq++);
    switch (f.toLowerCase()) {
      case "esri shapefile":
        path += ".shz";
        ext = ".shz";
        break;
      case "mapinfo file":
      case "flatgeobuf":
        ext = ".zip";
        break;
      default:
        path += ext;
    }
    return { path, ext };
  }
  createZipStream(p) {
    let archive = (0, import_archiver.default)("zip");
    archive.directory(p, false);
    archive.on("error", console.error);
    archive.finalize();
    return archive;
  }
  async run() {
    let command = this.customCommand ?? "ogr2ogr";
    let args = ["-f", this.outputFormat];
    if (this.skipFailures) args.push("-skipfailures");
    args.push(this.customDestination || this.outputPath, this.inputPath);
    if (this.customOptions) args.push(...this.customOptions);
    let env = this.customEnv ? { ...process.env, ...this.customEnv } : void 0;
    let { stdout, stderr } = await new Promise((res2, rej) => {
      let proc = (0, import_node_child_process.execFile)(
        command,
        args,
        { env, timeout: this.timeout, maxBuffer: this.maxBuffer },
        (err, stdout2, stderr2) => {
          if (err) rej(err);
          res2({ stdout: stdout2, stderr: stderr2 });
        }
      );
      if (this.inputStream && proc.stdin) this.inputStream.pipe(proc.stdin);
    });
    let res = {
      cmd: [command, ...args].join(" "),
      text: stdout,
      details: stderr,
      extname: this.outputExt
    };
    if (/^geojson$/i.test(this.outputFormat)) {
      try {
        res.data = JSON.parse(stdout);
      } catch (_err) {
      }
    }
    if (!this.customDestination && this.outputPath !== vsiStdOut) {
      if (this.outputExt === ".zip") {
        res.stream = this.createZipStream(this.outputPath);
      } else {
        res.stream = (0, import_node_fs.createReadStream)(this.outputPath);
      }
    }
    return res;
  }
};
function ogr2ogr(input, opts) {
  return new Ogr2ogr(input, opts);
}
ogr2ogr.version = async () => {
  let vers = await new Promise((res, rej) => {
    (0, import_node_child_process.execFile)("ogr2ogr", ["--version"], {}, (err, stdout) => {
      if (err) rej(err);
      res(stdout);
    });
  });
  return vers.trim();
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ogr2ogr
});
