// server/routes/matrung.route.js - FIXED VERSION WITH USER JOIN
const express = require("express");
const { Pool } = require("pg");
const router = express.Router();
const convertTcvn3ToUnicode = require("../utils/convertTcvn3ToUnicode");

const pool = new Pool();

router.get("/", async (req, res) => {
  const {
    fromDate,
    toDate,
    huyen,
    xa,
    tk,
    khoanh,
    churung,
    limit = 1000,
  } = req.query;

  try {
    // ‚úÖ TR∆Ø·ªúNG H·ª¢P 1: Kh√¥ng c√≥ filter g√¨ - l·∫•y d·ªØ li·ªáu 3 TH√ÅNG G·∫¶N NH·∫§T
    if (!fromDate && !toDate && !huyen && !xa && !tk && !khoanh && !churung) {
      console.log("üî¥ Loading d·ªØ li·ªáu mat_rung 3 th√°ng g·∫ßn nh·∫•t v·ªõi spatial intersection v√† user info...");
      
      const defaultQuery = `
        SELECT 
          m.gid,
          m.start_sau,
          m.area,
          m.start_dau,
          m.end_sau,
          m.mahuyen,
          m.end_dau,
          m.detection_status,
          m.detection_date,
          m.verified_by,
          m.verified_area,
          m.verification_reason,
          m.verification_notes,
          
          -- ‚úÖ FIX: JOIN v·ªõi b·∫£ng users ƒë·ªÉ l·∫•y t√™n th·∫≠t
          u.full_name as verified_by_name,
          u.username as verified_by_username,
          
          -- Th√¥ng tin t·ª´ spatial intersection
          r.huyen,
          r.xa,
          r.tieukhu as tk,
          r.khoanh,
          
          -- Extract t·ªça ƒë·ªô centroid
          ST_X(ST_Centroid(ST_Transform(m.geom, 4326))) as x_coordinate,
          ST_Y(ST_Centroid(ST_Transform(m.geom, 4326))) as y_coordinate,
          
          -- Geometry cho b·∫£n ƒë·ªì
          ST_AsGeoJSON(ST_Transform(m.geom, 4326)) as geometry
          
        FROM mat_rung m
        LEFT JOIN laocai_ranhgioihc r ON ST_Intersects(
          ST_Transform(m.geom, 4326), 
          ST_Transform(r.geom, 4326)
        )
        -- ‚úÖ FIX: LEFT JOIN v·ªõi b·∫£ng users
        LEFT JOIN users u ON m.verified_by = u.id
        WHERE m.geom IS NOT NULL 
          AND m.end_sau::date >= CURRENT_DATE - INTERVAL '3 months'
        ORDER BY m.end_sau DESC, m.gid DESC 
        LIMIT $1
      `;

      const defaultResult = await pool.query(defaultQuery, [limit]);

      // ‚úÖ X√¢y d·ª±ng GeoJSON v·ªõi th√¥ng tin user ƒë·∫ßy ƒë·ªß
      const features = defaultResult.rows.map(row => {
        // Fallback mapping cho huy·ªán n·∫øu kh√¥ng c√≥ spatial intersection
        const huyenMapping = {
          '01': 'L√†o Cai',
          '02': 'B√°t X√°t', 
          '03': 'M∆∞·ªùng Kh∆∞∆°ng',
          '04': 'Si Ma Cai',
          '05': 'B·∫Øc H√†',
          '06': 'B·∫£o Th·∫Øng',
          '07': 'B·∫£o Y√™n',
          '08': 'Sa Pa',
          '09': 'VƒÉn B√†n'
        };

        return {
          type: "Feature",
          geometry: JSON.parse(row.geometry),
          properties: {
            gid: row.gid,
            start_sau: row.start_sau,
            area: row.area,
            start_dau: row.start_dau,
            end_sau: row.end_sau,
            mahuyen: row.mahuyen,
            end_dau: row.end_dau,
            detection_status: row.detection_status,
            detection_date: row.detection_date,
            verified_by: row.verified_by,
            verified_area: row.verified_area,
            verification_reason: row.verification_reason,
            verification_notes: row.verification_notes,
            
            // ‚úÖ FIX: Th√™m th√¥ng tin ng∆∞·ªùi x√°c minh ƒë·∫ßy ƒë·ªß
            verified_by_name: row.verified_by_name,
            verified_by_username: row.verified_by_username,
            
            // ‚úÖ Th√¥ng tin t·ª´ spatial intersection (c√≥ fallback)
            huyen: convertTcvn3ToUnicode(row.huyen || huyenMapping[row.mahuyen] || `Huy·ªán ${row.mahuyen}`),
            xa: convertTcvn3ToUnicode(row.xa || ""),
            tk: row.tk,
            khoanh: row.khoanh,
            
            // ‚úÖ T·ªça ƒë·ªô
            x_coordinate: row.x_coordinate,
            y_coordinate: row.y_coordinate
          }
        };
      });

      const matRungGeoJSON = {
        type: "FeatureCollection",
        features: features
      };

      console.log(`‚úÖ Loaded ${matRungGeoJSON.features?.length || 0} mat_rung features (3 th√°ng g·∫ßn nh·∫•t) v·ªõi user info`);

      return res.json({
        message: `‚úÖ ƒê√£ t·∫£i ${matRungGeoJSON.features?.length || 0} khu v·ª±c m·∫•t r·ª´ng (3 th√°ng g·∫ßn nh·∫•t)`,
        mat_rung: matRungGeoJSON,
        tkk_3lr_cru: { type: "FeatureCollection", features: [] },
        isDefault: true,
        timeRange: '3_months',
        totalLoaded: matRungGeoJSON.features?.length || 0,
        spatialIntersectionUsed: true,
        userInfoIncluded: true // ‚úÖ Flag m·ªõi
      });
    }

    // ‚úÖ TR∆Ø·ªúNG H·ª¢P 2: C√≥ filter - s·ª≠ d·ª•ng spatial intersection + user info
    if (!fromDate || !toDate) {
      return res.status(400).json({ 
        message: "C·∫ßn c√≥ tham s·ªë t·ª´ ng√†y v√† ƒë·∫øn ng√†y khi t√¨m ki·∫øm c√≥ ƒëi·ªÅu ki·ªán." 
      });
    }

    console.log("üîç Loading d·ªØ li·ªáu mat_rung v·ªõi filter, spatial intersection v√† user info...");

    // ========= Truy v·∫•n v·ªõi spatial intersection + user info =========
    const conditions = [];
    const params = [];
    let index = 1;

    // ƒêi·ªÅu ki·ªán c∆° b·∫£n
    conditions.push(`m.start_dau >= $${index++}`);
    conditions.push(`m.end_sau <= $${index++}`);
    params.push(fromDate, toDate);

    // ƒêi·ªÅu ki·ªán spatial
    if (huyen) {
      conditions.push(`r.huyen = $${index++}`);
      params.push(huyen);
    }
    if (xa) {
      conditions.push(`r.xa = $${index++}`);
      params.push(xa);
    }
    if (tk) {
      conditions.push(`r.tieukhu = $${index++}`);
      params.push(tk);
    }
    if (khoanh) {
      conditions.push(`r.khoanh = $${index++}`);
      params.push(khoanh);
    }

    // Ch·ªß r·ª´ng t·ª´ b·∫£ng laocai_rg3lr
    let churungJoin = "";
    if (churung) {
      churungJoin = `LEFT JOIN laocai_rg3lr t ON ST_Intersects(m.geom, t.geom)`;
      conditions.push(`t.churung ILIKE $${index++}`);
      params.push(`%${churung}%`);
    }

    const whereClause = `WHERE ${conditions.join(" AND ")}`;

    const matRungQuery = `
      SELECT 
        m.gid,
        m.start_sau,
        m.area,
        m.start_dau,
        m.end_sau,
        m.mahuyen,
        m.end_dau,
        m.detection_status,
        m.detection_date,
        m.verified_by,
        m.verified_area,
        m.verification_reason,
        m.verification_notes,
        
        -- ‚úÖ FIX: Th√¥ng tin ng∆∞·ªùi x√°c minh
        u.full_name as verified_by_name,
        u.username as verified_by_username,
        
        -- Spatial intersection data
        r.huyen,
        r.xa,
        r.tieukhu as tk,
        r.khoanh,
        ${churung ? 't.churung,' : 'NULL as churung,'}
        
        -- Coordinates
        ST_X(ST_Centroid(ST_Transform(m.geom, 4326))) as x_coordinate,
        ST_Y(ST_Centroid(ST_Transform(m.geom, 4326))) as y_coordinate,
        
        -- Geometry
        ST_AsGeoJSON(ST_Transform(m.geom, 4326)) as geometry
        
      FROM mat_rung m
      LEFT JOIN laocai_ranhgioihc r ON ST_Intersects(
        ST_Transform(m.geom, 4326), 
        ST_Transform(r.geom, 4326)
      )
      -- ‚úÖ FIX: LEFT JOIN v·ªõi b·∫£ng users
      LEFT JOIN users u ON m.verified_by = u.id
      ${churungJoin}
      ${whereClause}
      AND m.geom IS NOT NULL
      ORDER BY m.end_sau DESC, m.gid DESC
      LIMIT $${index++}
    `;

    params.push(limit);

    const matRungResult = await pool.query(matRungQuery, params);

    // X√¢y d·ª±ng GeoJSON v·ªõi spatial data + user info
    const matRungFeatures = matRungResult.rows.map(row => {
      const huyenMapping = {
        '01': 'L√†o Cai',
        '02': 'B√°t X√°t', 
        '03': 'M∆∞·ªùng Kh∆∞∆°ng',
        '04': 'Si Ma Cai',
        '05': 'B·∫Øc H√†',
        '06': 'B·∫£o Th·∫Øng',
        '07': 'B·∫£o Y√™n',
        '08': 'Sa Pa',
        '09': 'VƒÉn B√†n'
      };

      return {
        type: "Feature",
        geometry: JSON.parse(row.geometry),
        properties: {
          gid: row.gid,
          start_sau: row.start_sau,
          area: row.area,
          start_dau: row.start_dau,
          end_sau: row.end_sau,
          mahuyen: row.mahuyen,
          end_dau: row.end_dau,
          detection_status: row.detection_status,
          detection_date: row.detection_date,
          verified_by: row.verified_by,
          verified_area: row.verified_area,
          verification_reason: row.verification_reason,
          verification_notes: row.verification_notes,
          
          // ‚úÖ FIX: Th√¥ng tin ng∆∞·ªùi x√°c minh ƒë·∫ßy ƒë·ªß
          verified_by_name: row.verified_by_name,
          verified_by_username: row.verified_by_username,
          
          // Spatial intersection data v·ªõi fallback
          huyen: convertTcvn3ToUnicode(row.huyen || huyenMapping[row.mahuyen] || `Huy·ªán ${row.mahuyen}`),
          xa: convertTcvn3ToUnicode(row.xa || ""),
          tk: row.tk,
          khoanh: row.khoanh,
          churung: convertTcvn3ToUnicode(row.churung || ""),
          
          // Coordinates
          x_coordinate: row.x_coordinate,
          y_coordinate: row.y_coordinate
        }
      };
    });

    const matRungGeoJSON = {
      type: "FeatureCollection",
      features: matRungFeatures
    };

    console.log(`‚úÖ Loaded ${matRungGeoJSON.features?.length || 0} mat_rung features v·ªõi filter v√† user info`);

    res.json({
      message: "‚úÖ D·ªØ li·ªáu ƒë√£ ƒë∆∞·ª£c truy xu·∫•t th√†nh c√¥ng v·ªõi spatial intersection v√† user info.",
      mat_rung: matRungGeoJSON,
      tkk_3lr_cru: { type: "FeatureCollection", features: [] },
      isDefault: false,
      spatialIntersectionUsed: true,
      userInfoIncluded: true, // ‚úÖ Flag m·ªõi
      filters: {
        fromDate,
        toDate,
        huyen,
        xa,
        tk,
        khoanh,
        churung
      }
    });
  } catch (err) {
    console.error("‚ùå L·ªói truy v·∫•n d·ªØ li·ªáu mat_rung:", err);
    res.status(500).json({ 
      message: "L·ªói server khi truy v·∫•n d·ªØ li·ªáu.", 
      error: err.message 
    });
  }
});

// ‚úÖ ENDPOINT: L·∫•y to√†n b·ªô d·ªØ li·ªáu mat_rung v·ªõi spatial intersection + user info
router.get("/all", async (req, res) => {
  const { limit = 1000, months = 3 } = req.query;
  
  try {
    console.log(`üî¥ Loading mat_rung data ${months} th√°ng g·∫ßn nh·∫•t v·ªõi user info, limit: ${limit}`);
    
    const query = `
      SELECT 
        m.gid,
        m.start_sau,
        m.area,
        m.start_dau,
        m.end_sau,
        m.mahuyen,
        m.end_dau,
        m.detection_status,
        m.detection_date,
        m.verified_by,
        m.verified_area,
        m.verification_reason,
        m.verification_notes,
        
        -- ‚úÖ FIX: Th√¥ng tin ng∆∞·ªùi x√°c minh
        u.full_name as verified_by_name,
        u.username as verified_by_username,
        
        -- Spatial intersection
        r.huyen,
        r.xa,
        r.tieukhu as tk,
        r.khoanh,
        
        -- Coordinates
        ST_X(ST_Centroid(ST_Transform(m.geom, 4326))) as x_coordinate,
        ST_Y(ST_Centroid(ST_Transform(m.geom, 4326))) as y_coordinate,
        
        -- Geometry
        ST_AsGeoJSON(ST_Transform(m.geom, 4326)) as geometry
        
      FROM mat_rung m
      LEFT JOIN laocai_ranhgioihc r ON ST_Intersects(
        ST_Transform(m.geom, 4326), 
        ST_Transform(r.geom, 4326)
      )
      -- ‚úÖ FIX: LEFT JOIN v·ªõi b·∫£ng users
      LEFT JOIN users u ON m.verified_by = u.id
      WHERE m.geom IS NOT NULL 
        AND m.end_sau::date >= CURRENT_DATE - INTERVAL '${months} months'
      ORDER BY m.end_sau DESC, m.gid DESC 
      LIMIT $1
    `;

    const result = await pool.query(query, [parseInt(limit)]);

    // X√¢y d·ª±ng GeoJSON v·ªõi spatial data + user info
    const features = result.rows.map(row => {
      const huyenMapping = {
        '01': 'L√†o Cai',
        '02': 'B√°t X√°t', 
        '03': 'M∆∞·ªùng Kh∆∞∆°ng',
        '04': 'Si Ma Cai',
        '05': 'B·∫Øc H√†',
        '06': 'B·∫£o Th·∫Øng',
        '07': 'B·∫£o Y√™n',
        '08': 'Sa Pa',
        '09': 'VƒÉn B√†n'
      };

      return {
        type: "Feature",
        geometry: JSON.parse(row.geometry),
        properties: {
          gid: row.gid,
          start_sau: row.start_sau,
          area: row.area,
          start_dau: row.start_dau,
          end_sau: row.end_sau,
          mahuyen: row.mahuyen,
          end_dau: row.end_dau,
          detection_status: row.detection_status,
          detection_date: row.detection_date,
          verified_by: row.verified_by,
          verified_area: row.verified_area,
          verification_reason: row.verification_reason,
          verification_notes: row.verification_notes,
          
          // ‚úÖ FIX: Th√¥ng tin ng∆∞·ªùi x√°c minh ƒë·∫ßy ƒë·ªß
          verified_by_name: row.verified_by_name,
          verified_by_username: row.verified_by_username,
          
          // Spatial data v·ªõi fallback
          huyen: convertTcvn3ToUnicode(row.huyen || huyenMapping[row.mahuyen] || `Huy·ªán ${row.mahuyen}`),
          xa: convertTcvn3ToUnicode(row.xa || ""),
          tk: row.tk,
          khoanh: row.khoanh,
          
          // Coordinates
          x_coordinate: row.x_coordinate,
          y_coordinate: row.y_coordinate
        }
      };
    });

    const geoJSON = {
      type: "FeatureCollection",
      features: features
    };

    console.log(`‚úÖ Successfully loaded ${geoJSON.features?.length || 0} mat_rung features (${months} th√°ng) v·ªõi user info`);

    res.json({
      success: true,
      message: `ƒê√£ t·∫£i ${geoJSON.features?.length || 0} khu v·ª±c m·∫•t r·ª´ng (${months} th√°ng g·∫ßn nh·∫•t)`,
      data: geoJSON,
      total: geoJSON.features?.length || 0,
      limit: parseInt(limit),
      timeRange: `${months}_months`,
      spatialIntersectionUsed: true,
      userInfoIncluded: true // ‚úÖ Flag m·ªõi
    });

  } catch (err) {
    console.error("‚ùå L·ªói khi l·∫•y to√†n b·ªô d·ªØ li·ªáu mat_rung:", err);
    res.status(500).json({ 
      success: false,
      message: "L·ªói server khi l·∫•y d·ªØ li·ªáu m·∫•t r·ª´ng",
      error: err.message 
    });
  }
});

// ‚úÖ ENDPOINT: L·∫•y th·ªëng k√™ d·ªØ li·ªáu mat_rung - C·∫¨P NH·∫¨T V·ªöI USER INFO
router.get("/stats", async (req, res) => {
  try {
    console.log("üìä Getting mat_rung statistics v·ªõi user info...");
    
    const statsQuery = `
      SELECT 
        COUNT(*) as total_records,
        COUNT(CASE WHEN m.geom IS NOT NULL THEN 1 END) as records_with_geometry,
        COUNT(CASE WHEN r.gid IS NOT NULL THEN 1 END) as records_with_spatial_data,
        COUNT(CASE WHEN m.end_sau::date >= CURRENT_DATE - INTERVAL '3 months' THEN 1 END) as recent_3_months,
        COUNT(CASE WHEN m.end_sau::date >= CURRENT_DATE - INTERVAL '12 months' THEN 1 END) as recent_12_months,
        MIN(m.start_dau) as earliest_date,
        MAX(m.end_sau) as latest_date,
        SUM(m.area) as total_area,
        COUNT(DISTINCT m.mahuyen) as unique_districts,
        COUNT(DISTINCT r.huyen) as unique_huyen_names,
        COUNT(DISTINCT r.xa) as unique_xa_names,
        -- ‚úÖ FIX: Th·ªëng k√™ v·ªÅ x√°c minh
        COUNT(CASE WHEN m.detection_status = 'ƒê√£ x√°c minh' THEN 1 END) as verified_records,
        COUNT(CASE WHEN m.verified_by IS NOT NULL THEN 1 END) as records_with_verifier,
        COUNT(DISTINCT m.verified_by) as unique_verifiers
      FROM mat_rung m
      LEFT JOIN laocai_ranhgioihc r ON ST_Intersects(
        ST_Transform(m.geom, 4326), 
        ST_Transform(r.geom, 4326)
      )
      LEFT JOIN users u ON m.verified_by = u.id;
    `;

    const result = await pool.query(statsQuery);
    const stats = result.rows[0];

    // Format area th√†nh hectares
    stats.total_area_ha = stats.total_area ? parseFloat((stats.total_area / 10000).toFixed(2)) : 0;
    stats.spatial_intersection_rate = stats.total_records > 0 
      ? ((stats.records_with_spatial_data / stats.total_records) * 100).toFixed(2) + '%'
      : '0%';
    stats.verification_rate = stats.total_records > 0
      ? ((stats.verified_records / stats.total_records) * 100).toFixed(2) + '%'
      : '0%';

    console.log("üìä Mat rung statistics v·ªõi user info:", stats);

    res.json({
      success: true,
      data: stats
    });

  } catch (err) {
    console.error("‚ùå L·ªói khi l·∫•y th·ªëng k√™ mat_rung:", err);
    res.status(500).json({ 
      success: false,
      message: "L·ªói server khi l·∫•y th·ªëng k√™",
      error: err.message 
    });
  }
});

module.exports = router;